"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[69982],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var o=t(67294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,s=function(e,n){if(null==e)return{};var t,o,s={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(t),u=s,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||r;return t?o.createElement(m,a(a({ref:n},p),{},{components:t})):o.createElement(m,a({ref:n},p))}));function m(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,a=new Array(r);a[0]=u;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[d]="string"==typeof e?e:s,a[1]=i;for(var c=2;c<r;c++)a[c]=t[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5747:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var o=t(87462),s=(t(67294),t(3905));const r={},a="Building Real-time Apps with Websockets & Server-Sent Events",i={unversionedId:"WebAPI/web-sockets/Building Real-time Apps with Websockets",id:"WebAPI/web-sockets/Building Real-time Apps with Websockets",title:"Building Real-time Apps with Websockets & Server-Sent Events",description:"https://www.sitepoint.com/real-time-apps-websockets-server-sent-events",source:"@site/docs/WebAPI/web-sockets/Building Real-time Apps with Websockets.md",sourceDirName:"WebAPI/web-sockets",slug:"/WebAPI/web-sockets/Building Real-time Apps with Websockets",permalink:"/notebook/docs/WebAPI/web-sockets/Building Real-time Apps with Websockets",draft:!1,editUrl:"https://github.com/scheffershen/notebook/tree/main/docs/WebAPI/web-sockets/Building Real-time Apps with Websockets.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Create a Real-Time Video Chat Room with WebRTC & Twilio",permalink:"/notebook/docs/WebAPI/web-rtc/real-time-video-chat-room"},next:{title:"Can't connect to WSS/SSL websocket server with a self-signed certificate",permalink:"/notebook/docs/WebAPI/web-sockets/Cant connect to WSS SSL websocket server with a self-signed certificate"}},l={},c=[{value:"WebSockets",id:"websockets",level:2},{value:"Server-Sent Events",id:"server-sent-events",level:2},{value:"Frameworks",id:"frameworks",level:2}],p={toc:c};function d(e){let{components:n,...t}=e;return(0,s.kt)("wrapper",(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"building-real-time-apps-with-websockets--server-sent-events"},"Building Real-time Apps with Websockets & Server-Sent Events"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://www.sitepoint.com/real-time-apps-websockets-server-sent-events"},"https://www.sitepoint.com/real-time-apps-websockets-server-sent-events")),(0,s.kt)("p",null,"Mark Brown\nJune 06, 2016"),(0,s.kt)("p",null,"Things continued to get interesting in 2011 when the WebSocket protocol was standardised. WebSockets allow you to open a two-way persistent connection between client and server, giving you the ability to push data back to the clients whenever data changes on the server without the client having to request it. "),(0,s.kt)("p",null,"However, it wasn\u2019t until socket.io\u2014the most prominent effort to bring WebSockets to the masses\u2014was released in 2014 that we saw a lot more experimentation happening with real time communication."),(0,s.kt)("p",null,"These technologies give you the ability to stream data back to the client the moment things happen on the server."),(0,s.kt)("h2",{id:"websockets"},"WebSockets"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Demo")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"$ git clone https://github.com/sitepoint-editors/websocket-demo.git\n$ cd websocket-demo\n$ npm install\n$ npm start\n")),(0,s.kt)("p",null,"Open http://localhost:8080/ in multiple browser windows and observe the logs in both the browser and the server to see messages going back and forth."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"The Client")),(0,s.kt)("p",null,"The ",(0,s.kt)("strong",{parentName:"p"},"WebSocket")," constructor initiates a connection with the server over the ",(0,s.kt)("strong",{parentName:"p"},"ws")," or ",(0,s.kt)("strong",{parentName:"p"},"wss"),"(Secure) protocols. It has a ",(0,s.kt)("strong",{parentName:"p"},"send")," method for pushing data to the server and you can provide an ",(0,s.kt)("strong",{parentName:"p"},"onmessage")," handler for receiving data from the server."),(0,s.kt)("p",null,"Here\u2019s an annotated example showing all of the important events:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"    // Open a connection\n    var socket = new WebSocket('ws://localhost:8081/');\n\n    // When a connection is made\n    socket.onopen = function() {\n      console.log('Opened connection ');\n\n      // send data to the server\n      var json = JSON.stringify({ message: 'Hello ' });\n      socket.send(json);\n    }\n\n    // When data is received\n    socket.onmessage = function(event) {\n      console.log(event.data);\n    }\n\n    // A connection could not be made\n    socket.onerror = function(event) {\n      console.log(event);\n    }\n\n    // A connection was closed\n    socket.onclose = function(code, reason) {\n      console.log(code, reason);\n    }\n\n    // Close the connection when the window is closed\n    window.addEventListener('beforeunload', function() {\n      socket.close();\n    });\n\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"The Server")),(0,s.kt)("p",null,"By far, the most popular Node library for working with WebSockets on the server is ",(0,s.kt)("strong",{parentName:"p"},"ws"),", we\u2019ll use that to simplify things as writing WebSocket servers is not a trivial task."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"    var WSS = require('ws').Server;\n\n    // Start the server\n    var wss = new WSS({ port: 8081 });\n\n    // When a connection is established\n    wss.on('connection', function(socket) {\n      console.log('Opened connection ');\n\n      // Send data back to the client\n      var json = JSON.stringify({ message: 'Gotcha' });\n      socket.send(json);\n\n      // When data is received\n      socket.on('message', function(message) {\n        console.log('Received: ' + message);\n      });\n\n      // The connection was closed\n      socket.on('close', function() {\n        console.log('Closed Connection ');\n      });\n\n    });\n\n    // Every three seconds broadcast \"{ message: 'Hello hello!' }\" to all connected clients\n    var broadcast = function() {\n      var json = JSON.stringify({\n        message: 'Hello hello!'\n      });\n\n      // wss.clients is an array of all connected clients\n      wss.clients.forEach(function each(client) {\n        client.send(json);\n        console.log('Sent: ' + json);\n      });\n    }\n    setInterval(broadcast, 3000);    \n\n")),(0,s.kt)("p",null,"Browser support for WebSockets is solid, "),(0,s.kt)("h2",{id:"server-sent-events"},"Server-Sent Events"),(0,s.kt)("p",null,"Like WebSockets, SSE opens a persistent connection that allows you to send data back to the connected clients the second something is changed on the server. "),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Demo")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"$ git clone https://github.com/sitepoint-editors/server-sent-events-demo.git\n$ cd server-sent-events-demo\n$ npm install\n$ npm start\n")),(0,s.kt)("p",null,"As before, open http://localhost:8080/ in multiple browser windows and observe the logs in both the browser and the server to see messages going back and forth."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"The client")),(0,s.kt)("p",null,"The ",(0,s.kt)("strong",{parentName:"p"},"EventSource")," function initiates a connection with the server over good old HTTP or HTTPS. It has a similar API to ",(0,s.kt)("strong",{parentName:"p"},"WebSocket")," and you can provide an ",(0,s.kt)("strong",{parentName:"p"},"onmessage")," handler for receiving data from the server. "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"    // Open a connection\n    var stream = new EventSource(\"/sse\");\n\n    // When a connection is made\n    stream.onopen = function() {\n      console.log('Opened connection ');\n    };\n\n    // A connection could not be made\n    stream.onerror = function (event) {\n      console.log(event);\n    };\n\n    // When data is received\n    stream.onmessage = function (event) {\n      console.log(event.data);\n    };\n\n    // A connection was closed\n    stream.onclose = function(code, reason) {\n      console.log(code, reason);\n    }\n\n    // Close the connection when the window is closed\n    window.addEventListener('beforeunload', function() {\n      stream.close();\n    });\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"The Server")),(0,s.kt)("p",null,"There\u2019s a neat little wrapper sse for creating server-sent events. We\u2019ll use that to simplify things at first but sending events from the server is simple enough to do ourselves so we\u2019ll explain how SSE on the server works later."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"    var SSE = require('sse');\n    var http = require('http');\n\n    var server = http.createServer();\n    var clients = [];\n\n    server.listen(8080, '127.0.0.1', function() {\n      // initialize the /sse route\n      var sse = new SSE(server);\n\n      // When a connection is made\n      sse.on('connection', function(stream) {\n        console.log('Opened connection ');\n        clients.push(stream);\n\n        // Send data back to the client\n        var json = JSON.stringify({ message: 'Gotcha' });\n        stream.send(json);\n        console.log('Sent: ' + json);\n\n        // The connection was closed\n        stream.on('close', function() {\n          clients.splice(clients.indexOf(stream), 1);\n          console.log('Closed connection ');\n        });\n      });\n    });\n\n\n   // Every three seconds broadcast \"{ message: 'Hello hello!' }\" to all connected clients\n    var broadcast = function() {\n      var json = JSON.stringify({ message: 'Hello hello!' });\n\n      clients.forEach(function(stream) {\n        stream.send(json);\n        console.log('Sent: ' + json);\n      });\n    }\n    setInterval(broadcast, 3000) \n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Sending Events from the Server")),(0,s.kt)("p",null,"When a HTTP request comes in from ",(0,s.kt)("strong",{parentName:"p"},"EventSource")," it will have an ",(0,s.kt)("strong",{parentName:"p"},"Accept")," header of ",(0,s.kt)("strong",{parentName:"p"},"text/event-stream"),", we need to respond with headers that keep the HTTP connection alive, then when we are ready to send data back to the client we write data to the ",(0,s.kt)("strong",{parentName:"p"},"Response")," object in a special format ",(0,s.kt)("strong",{parentName:"p"},"data"),": ","<","data",">","\\n\\n."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"    http.createServer(function(req, res) {\n\n      // Open a long held http connection\n      res.writeHead(200, {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache',\n        'Connection': 'keep-alive'\n      });\n\n      // Send data to the client\n      var json = JSON.stringify({ message: 'Hello ' });\n      res.write(\"data: \" + json + \"\\n\\n\");\n\n    }).listen(8000);\n\n")),(0,s.kt)("p",null,"Although ",(0,s.kt)("strong",{parentName:"p"},"SSE")," is wonderfully simple to implement on both the client and the server, as mentioned above, its one caveat is that it doesn\u2019t provide a way to send data from the client to the server."),(0,s.kt)("p",null,"Luckily, we can already do that with ",(0,s.kt)("strong",{parentName:"p"},"XMLHttpRequest")," or ",(0,s.kt)("strong",{parentName:"p"},"fetch"),". Our new found superpower is to be able to push from the server to the client."),(0,s.kt)("p",null,"For security, as it\u2019s HTTP the standard Cross-Origin rules apply so you should always whitelist origins on both the server and the client:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"stream.onmessage = function(event) {\n  if (e.origin != 'http://example.com') return;\n}\n")),(0,s.kt)("p",null,"Then we can still push to the server as usual with good old Ajax:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"    document.querySelector('#send').addEventListener('click', function(event) {\n      var json = JSON.stringify({ message: 'Hey there' });\n\n      var xhr = new XMLHttpRequest();\n      xhr.open('POST', '/api', true);\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      xhr.send(json);\n\n      log('Sent: ' + json);\n    });\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Browser Compatibility")),(0,s.kt)("p",null,"Browser support for SSE is lower than WebSocket due to Microsoft never having shipped a browser that supports it, there is a bug report for it and you should all vote for SSE to help make it a priority for the next release."),(0,s.kt)("h2",{id:"frameworks"},"Frameworks"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"socket.io"),(0,s.kt)("li",{parentName:"ul"},"Meteor"),(0,s.kt)("li",{parentName:"ul"},"Phoenix \u2013 Channels"),(0,s.kt)("li",{parentName:"ul"},"Rails 5 \u2013 ActionCable")))}d.isMDXComponent=!0}}]);