"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[777],{6334:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"comment-optimiser-l-application-symfony","metadata":{"permalink":"/notebook/blog/comment-optimiser-l-application-symfony","editUrl":"https://github.com/scheffershen/notebook/tree/main/blog/2021-12-13-comment-optimiser-l-application-symfony/index.md","source":"@site/blog/2021-12-13-comment-optimiser-l-application-symfony/index.md","title":"Comment optimiser l\'application symfony","description":"1. Activer OpCache extension","date":"2021-12-13T00:00:00.000Z","formattedDate":"December 13, 2021","tags":[{"label":"symfony","permalink":"/notebook/blog/tags/symfony"},{"label":"php","permalink":"/notebook/blog/tags/php"},{"label":"optimisation","permalink":"/notebook/blog/tags/optimisation"}],"readingTime":4.25,"hasTruncateMarker":false,"authors":[{"name":"Yi Shen","title":"Web Developer","url":"https://github.com/scheffershen","imageURL":"https://github.com/scheffershen.png","key":"yshen"}],"frontMatter":{"slug":"comment-optimiser-l-application-symfony","title":"Comment optimiser l\'application symfony","authors":["yshen"],"tags":["symfony","php","optimisation"]}},"content":"### 1. Activer OpCache extension\\r\\n\\r\\nOpCache. Il compile et optimise les scripts PHP et les met en cache m\xe9moire afin qu\'ils ne soient pas compil\xe9s chaque fois que la page est charg\xe9e.\\r\\n\\r\\ninstallation: \\r\\n\\r\\n\\t$ sudo apt install php7.4-opcache\\r\\n\\r\\nconfiguration: \\r\\n\\r\\n/etc/php7.4/conf.d/opcache.ini \\r\\n\\r\\n```\\r\\nopcache.memory_consumption=512 ;for caching all compiled files\\r\\nopcache.interned_strings_buffer=32\\r\\nopcache.max_accelerated_files=32531 ;by default can cache 2000 files\\r\\nopcache.revalidate_freq=60\\r\\nopcache.fast_shutdown=1\\r\\nopcache.enable_cli=0\\r\\nopcache.enable=1\\r\\nopcache.save_comments=1\\r\\n```\\r\\n\\r\\n### 2. Asynchroniser les requ\xeats simultan\xe9ment\\r\\n\\r\\nexemple 1: symfony 3.4 et php 7.2\\r\\n\\r\\n```php\\r\\nuse Icicle\\\\{Coroutine\\\\Coroutine, Loop, Awaitable};\\r\\n\\r\\n$_tickets =  new Coroutine($ticket->findAll());\\r\\n$tickets = $_tickets->wait();\\r\\n$_interactions =  new Coroutine($interaction->findAll());\\r\\n$interactions = $_interactions->wait();\\r\\n$_faqs =  new Coroutine($faq->findAll());\\r\\n$faqs = $_faqs->wait();\\r\\n...\\r\\n\\r\\nLoop\\\\Run();\\r\\n```\\r\\n\\r\\n### 3. Utiliser la fonction g\xe9n\xe9rateur pour consommer moins des m\xe9moires\\r\\n\\r\\nUn g\xe9n\xe9rateur vous permet d\'\xe9crire du code qui utilise foreach pour parcourir un jeu de donn\xe9es, sans avoir \xe0 construire un tableau en m\xe9moire pouvant conduire \xe0 d\xe9passer la limite de la m\xe9moire ou n\xe9cessiter un temps important pour sa g\xe9n\xe9ration.\\r\\n\\r\\nune fonction g\xe9n\xe9rateur, qui est identique \xe0 une fonction normale, mis \xe0 part le fait qu\'au lieu de retourner une seule fois, un g\xe9n\xe9rateur peut utiliser yield autant de fois que n\xe9cessaire, afin de fournir les valeurs \xe0 parcourir.\\r\\n\\r\\nUn exemple simple de ce m\xe9canisme est la r\xe9-impl\xe9mentation de la fonction range() sous la forme d\'un g\xe9n\xe9rateur. La fonction standard range() doit g\xe9n\xe9rer un tableau contenant chaque valeur, et le retourner, ce qui peut conduire \xe0 des tableaux de taille importante : par exemple, l\'appel du code range(0, 1000000) peut consommer nettement plus de 100 Mo de m\xe9moire.\\r\\n\\r\\nComme alternative, nous pouvons impl\xe9menter un g\xe9n\xe9rateur xrange(), qui n\'aura en besoin m\xe9moire que la seule cr\xe9ation d\'un objet Iterator, et devra garder trace en interne du statut courant du g\xe9n\xe9rateur, ce qui revient \xe0 une consommation m\xe9moire inf\xe9rieure \xe0 1 Ko.\\r\\n\\r\\nexemple: findAll() \\r\\n\\r\\n```php\\r\\n    public function findAll()\\r\\n    {\\r\\n        $queryBuilder = $this->createQueryBuilder(\'t\')\\r\\n            ->select(\'t.id, t.question, t.answer, t.answer, t.date\')\\r\\n            ->orderBy(\'t.id\');\\r\\n\\r\\n        $limit = 1000;\\r\\n        $offset = 0;\\r\\n\\r\\n        while (true) {\\r\\n            $queryBuilder->setFirstResult($offset);\\r\\n            $queryBuilder->setMaxResults($limit);\\r\\n\\r\\n            $tickets = $queryBuilder->getQuery()->getResult();\\r\\n\\r\\n            if (count($tickets) === 0) {\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            foreach ($tickets as $ticket) {\\r\\n                yield $ticket;\\r\\n                $this->_em->detach($ticket);\\r\\n            }\\r\\n\\r\\n            $offset += $limit;\\r\\n        }\\r\\n    } \\r\\n```\\r\\n\\r\\n### 3. Eviter d\'utiliser \\"select * \\" dans le doctrine requ\xeate.\\r\\n\\r\\nexemple: \\r\\n\\r\\n\\tSELECT F.id, F.reference FROM FAQ F WHERE F.isValid = 1\\r\\n\\r\\n### 4. Activer le cache de Doctrine.\\r\\n\\r\\nIl faut savoir qu\u2019il y a 3 types de cache pour Doctrine :\\r\\n\\r\\n- Query Cache : transformation DQL -> SQL;\\r\\n- Result Cache : r\xe9sultat de la requ\xeate;\\r\\n- Metadata Cache : annotation des entities.\\r\\n\\r\\ninstallation: \\r\\n\\r\\n    $ sudo apt install redis-server\\r\\n    $ composer require snc/redis-bundle\\r\\n\\r\\nconfiguration: \\r\\n\\r\\n```yaml\\r\\n# Doctrine Configuration\\r\\ndoctrine:\\r\\n  dbal:\\r\\n    #...\\r\\n  orm:\\r\\n    auto_generate_proxy_classes: \'%kernel.debug%\'\\r\\n    naming_strategy: doctrine.orm.naming_strategy.underscore\\r\\n    # IMPORTANT!\\r\\n    auto_mapping: true\\r\\n    metadata_cache_driver: redis\\r\\n    query_cache_driver: redis\\r\\n\\r\\n```\\r\\n\\r\\nMettre en cache le r\xe9sultat\\r\\n\\r\\n```php\\r\\npublic function findBeers()\\r\\n{\\r\\n    $query = $this->getEntityManager()\\r\\n        ->createQuery(\\r\\n            \'select beers from MaxpouBeerBundle:Beers b\'\\r\\n        )\\r\\n    ;\\r\\n\\r\\n    $query->useResultCache(true);\\r\\n    $query->setResultCacheLifetime(3600); //3600sec = 1 hour\\r\\n\\r\\n    return $query->getResult();\\r\\n}\\r\\n```\\r\\n\\r\\nPour nettoyer le cache, voici quelques commandes \\r\\n\\r\\n    # Nettoyer cache des queries\\r\\n    $ php bin/console doctrine:cache:clear-query\\r\\n    # Nettoyer cache des metadatas\\r\\n    $ php bin/console doctrine:cache:clear-metadata\\r\\n    # Nettoyer cache des r\xe9sultats\\r\\n    $ php bin/console doctrine:cache:clear-result\\r\\n    # Vider la base redis\\r\\n    $ php bin/console redis:flushdb\\r\\n\\r\\n### 5. Mise en cache les HTTP req\xeates\\r\\n\\r\\nexemple: \\r\\n\\r\\n```php\\r\\n    $response = $this->render(\'SearchManagement/Dci/index.html.twig\', [\\r\\n        \'dcis\' => $this->dciRepository->findAll(),\\r\\n    ]);\\r\\n\\r\\n    $response->setSharedMaxAge(60);\\r\\n\\r\\n    return $response;\\r\\n```\\r\\n\\r\\n### 6. Augementer le nombre des cores, la fr\xe9quence de cpu, et la RAM\\r\\n\\r\\nPHP n\'est pas con\xe7u pour le multithreading. Par cons\xe9quent, chaque page/requ\xeate est servie par un processus PHP et chaque processus se verrouille sur un c\u0153ur de processeur.\\r\\n\\r\\nSi votre serveur Web a des demandes de pages simultan\xe9es, vous aurez \xe9galement plusieurs processus PHP - chacun utilisant un c\u0153ur de processeur - s\'ex\xe9cutant simultan\xe9ment.\\r\\n\\r\\nS\'il faut 3 secondes \xe0 un c\u0153ur de processeur \xe0 2 GHz pour traiter une demande, un c\u0153ur de processeur \xe0 3 GHz renvoie la m\xeame demande en 2 secondes environ.\\r\\n\\r\\nLa r\xe8gle est RAM=2x(Nombre de Cores) Go ou RAM=4x(Nombre de Cores) Go\\r\\n\\r\\n### 7. Augementer la taille du swap \\r\\n\\r\\nAugmenter l\'espace d\'\xe9change (SWAP), la r\xe8gle d\'or est swap=2xRAM.\\r\\n\\r\\nLinux supporte la m\xe9moire virtuelle, c\'est \xe0 dire l\'utilisation d\'un disque comme extension de la RAM de telle sorte que la taille effective de la m\xe9moire utilisable s\'accro\xeet d\'autant. Le noyau \xe9crira le contenu d\'un bloc m\xe9moire inutilis\xe9 sur le disque dur, ainsi la m\xe9moire vive peut \xeatre utilis\xe9e pour autre chose. Quand ce contenu est \xe0 nouveau n\xe9cessaire, il est relu en m\xe9moire. Tout ceci se d\xe9roule de fa\xe7on transparente pour l\'utilisateur ; les programmes s\'ex\xe9cutant sous Linux voient seulement toute la m\xe9moire disponible et ne remarquent pas que des parties de celle-ci se trouvent sur le disque de temps \xe0 autre. Bien s\xfbr, lire et \xe9crire sur le disque dur est plus lent (de l\'ordre de mille fois plus lent) qu\'en utilisant la m\xe9moire r\xe9elle et donc les programmes ne s\'ex\xe9cutent pas aussi vite. La partie du disque dur utilis\xe9e comme m\xe9moire virtuelle est appel\xe9e espace de swap\\r\\n\\r\\n### 8. Utiliser le crontab pour les t\xe2ches lourdes\\r\\n\\r\\nCrontab est un outil qui permet de lancer des applications de fa\xe7on r\xe9guli\xe8re, pratique pour un serveur pour y lancer des scripts de sauvegardes, etc"}]}')}}]);